"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.randomList = exports.randomInt = exports.prevState = exports.nextState = exports.stepState = void 0;
const long_1 = __importDefault(require("long"));
const ramda_1 = require("ramda");
const defaults_1 = require("./defaults");
const types_1 = require("./types");
/* Multi-step advance functions (jump-ahead, jump-back)
 *
 * The method used here is based on Brown, "Random Number Generation with Arbitrary Stride,",
 * Transactions of the American Nuclear Society (Nov. 1994). The algorithm is very similar to fast
 * exponentiation.
 *
 * Even though delta is an unsigned integer, we can pass a signed integer to go backwards, it just
 * goes "the long way round".
 */
exports.stepState = (0, ramda_1.curry)((delta, pcg) => {
    let currMultiplier = pcg.algorithm.multiplier;
    const incrementers = {
        [types_1.StreamScheme.SETSEQ]: () => pcg.streamId,
        [types_1.StreamScheme.ONESEQ]: () => pcg.algorithm.increment,
        // TODO: [StreamScheme.UNIQUE]: () => null,
        [types_1.StreamScheme.MCG]: () => long_1.default.fromInt(0, true),
    };
    let currIncrement = incrementers[pcg.algorithm.streamScheme]();
    let accMultiplier = long_1.default.fromInt(1, true);
    let accIncrement = long_1.default.fromInt(0, true);
    for (let remainingDelta = long_1.default.fromValue(delta).toUnsigned(); remainingDelta.gt(0); remainingDelta = remainingDelta.shru(1)) {
        if (remainingDelta.isOdd()) {
            accMultiplier = accMultiplier.mul(currMultiplier);
            accIncrement = accIncrement.mul(currMultiplier).add(currIncrement);
        }
        currIncrement = currMultiplier.add(1).mul(currIncrement);
        currMultiplier = currMultiplier.mul(currMultiplier);
    }
    return {
        ...pcg,
        state: pcg.state.mul(accMultiplier).add(accIncrement),
    };
});
exports.nextState = (0, exports.stepState)(1);
exports.prevState = (0, exports.stepState)(-1);
exports.randomInt = (0, ramda_1.curry)((min, max, pcg) => {
    const bound = max - min;
    if (bound < 0 || bound >= pcg.algorithm.outputMaxRange)
        throw new RangeError();
    const threshold = (pcg.algorithm.outputMaxRange - bound) % bound;
    // Uniformity guarantees that this loop will terminate
    let n;
    let nextPcg = pcg;
    do {
        n = long_1.default.fromValue(nextPcg.getOutput(pcg.state));
        nextPcg = (0, exports.nextState)(nextPcg);
    } while (n.lt(threshold));
    return [n.mod(bound).add(min).toNumber(), nextPcg];
});
exports.randomList = (0, ramda_1.curry)((length, rng, pcg) => (0, ramda_1.scan)(([, nextPcg]) => rng(nextPcg), rng(pcg), new Array(length - 1)));
exports.default = (0, ramda_1.curry)(({ numOutputBits, multiplier, increment, outputFns }, { streamScheme = defaults_1.pcgDefaultStreamScheme, outputFnType = defaults_1.pcgDefaultOutputFnType }, initState, initStreamId) => {
    const streamId = long_1.default.fromValue(initStreamId).toUnsigned().shl(1).or(1);
    return (0, exports.nextState)({
        state: streamId.add(initState),
        streamId,
        algorithm: {
            streamScheme,
            outputFnType,
            outputMaxRange: 2 ** numOutputBits,
            multiplier,
            increment,
        },
        getOutput: outputFns[outputFnType],
    });
});
